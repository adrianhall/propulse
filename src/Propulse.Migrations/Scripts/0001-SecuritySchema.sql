/*
==============================================================================
ASP.NET Core Identity Schema for PostgreSQL
==============================================================================

Purpose:
    Creates the complete database schema required for ASP.NET Core Identity
    authentication and authorization system.

Database: PostgreSQL 17+
Schema: security
Extensions: citext (case-insensitive text), uuid-ossp (UUID generation)

Tables Created:
    - Roles: Application roles (Admin, User, etc.)
    - RoleClaims: Claims associated with roles
    - Users: User accounts and authentication data
    - UserClaims: Claims associated with individual users
    - UserLogins: External login provider associations
    - UserRoles: Many-to-many relationship between users and roles
    - UserTokens: Authentication tokens (password reset, email confirmation, etc.)

Key Features:
    - UUID primary keys for better performance and distribution
    - CITEXT data type for case-insensitive username/email comparisons
    - Comprehensive indexing for query performance
    - Foreign key constraints with CASCADE DELETE for data integrity
    - Optimized for ASP.NET Core Identity Entity Framework integration

Compatibility:
    - ASP.NET Core Identity 8.0+
    - Entity Framework Core 8.0+
    - PostgreSQL 17+ with citext and uuid-ossp extensions

==============================================================================
*/

-- Enable required PostgreSQL extensions
CREATE EXTENSION IF NOT EXISTS "citext";
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

-- Create dedicated schema for security/identity tables
-- Separates identity data from application data for better organization
CREATE SCHEMA IF NOT EXISTS "$SecuritySchemaName$";

/*
==============================================================================
ROLES TABLE
==============================================================================
Stores application roles (e.g., Admin, Manager, User)
Used by ASP.NET Core Identity for role-based authorization
*/
CREATE TABLE "$SecuritySchemaName$"."Roles" (
    "Id"                          UUID                          NOT NULL DEFAULT uuid_generate_v4(),
    "Name"                        CITEXT                        NOT NULL,         -- Original role name (case-insensitive)
    "NormalizedName"              CITEXT                        NOT NULL,         -- Uppercase role name for lookups
    "ConcurrencyStamp"            TEXT,                                           -- EF Core optimistic concurrency token
    CONSTRAINT "PK_Roles" PRIMARY KEY ("Id")
);

-- Ensure role names are unique (case-insensitive)
CREATE UNIQUE INDEX "IDX_Roles_Name" ON "$SecuritySchemaName$"."Roles" ("NormalizedName");

-- Data quality constraints for Roles table
ALTER TABLE "$SecuritySchemaName$"."Roles" ADD CONSTRAINT "CHK_Roles_NormalizedName_NotBlank" 
    CHECK ("NormalizedName" = TRIM("NormalizedName") AND LENGTH(TRIM("NormalizedName")) > 0);

/*
==============================================================================
ROLE CLAIMS TABLE
==============================================================================
Stores claims (permissions/attributes) associated with roles
Enables fine-grained authorization beyond simple role membership
*/
CREATE TABLE "$SecuritySchemaName$"."RoleClaims" (
    "Id"                          INTEGER                       NOT NULL GENERATED BY DEFAULT AS IDENTITY,
    "RoleId"                      UUID                          NOT NULL,         -- Foreign key to Roles table
    "ClaimType"                   TEXT                          NOT NULL,         -- Claim type (e.g., "permission")
    "ClaimValue"                  TEXT,                                           -- Claim value (e.g., "users.read")
    CONSTRAINT "PK_RoleClaims" PRIMARY KEY ("Id")
);

-- Performance indices for common queries
CREATE INDEX "IX_RoleClaims_RoleId" ON "$SecuritySchemaName$"."RoleClaims" ("RoleId");
CREATE INDEX "IX_RoleClaims_ClaimType" ON "$SecuritySchemaName$"."RoleClaims" ("ClaimType");

-- Maintain referential integrity with cascade delete
ALTER TABLE "$SecuritySchemaName$"."RoleClaims" ADD CONSTRAINT "FK_RoleClaims_RoleId" 
    FOREIGN KEY ("RoleId") REFERENCES "$SecuritySchemaName$"."Roles" ("Id") 
    ON DELETE CASCADE;

-- Data quality constraints for RoleClaims table
ALTER TABLE "$SecuritySchemaName$"."RoleClaims" ADD CONSTRAINT "CHK_RoleClaims_ClaimType_NotBlank" 
    CHECK ("ClaimType" = TRIM("ClaimType") AND LENGTH(TRIM("ClaimType")) > 0);

/*
==============================================================================
USERS TABLE
==============================================================================
Core user accounts table containing all ASP.NET Core Identity user properties
Includes authentication data, profile information, and security settings
*/
CREATE TABLE "$SecuritySchemaName$"."Users" (
    "Id"                          UUID                          NOT NULL DEFAULT uuid_generate_v4(),
    "UserName"                    CITEXT                        NOT NULL,               -- Display username (case-insensitive)
    "NormalizedUserName"          CITEXT                        NOT NULL,               -- Uppercase username for lookups
    "Email"                       CITEXT                        NOT NULL,               -- Email address (case-insensitive)
    "NormalizedEmail"             CITEXT                        NOT NULL,               -- Uppercase email for lookups
    "EmailConfirmed"              BOOLEAN                       NOT NULL DEFAULT FALSE, -- Email verification status
    "PasswordHash"                TEXT,                                                 -- Hashed password (nullable for external logins)
    "SecurityStamp"               TEXT,                                                 -- Security token invalidation stamp
    "ConcurrencyStamp"            TEXT,                                                 -- EF Core optimistic concurrency token
    "PhoneNumber"                 TEXT,                                                 -- Phone number for 2FA
    "PhoneNumberConfirmed"        BOOLEAN                       NOT NULL DEFAULT FALSE, -- Phone verification status
    "TwoFactorEnabled"            BOOLEAN                       NOT NULL DEFAULT FALSE, -- 2FA enablement flag
    "LockoutEnd"                  TIMESTAMPTZ,                                          -- Account lockout expiration (UTC)
    "LockoutEnabled"              BOOLEAN                       NOT NULL DEFAULT FALSE, -- Account lockout capability
    "AccessFailedCount"           INTEGER                       NOT NULL DEFAULT 0,     -- Failed login attempt counter
    CONSTRAINT "PK_Users" PRIMARY KEY ("Id")
);

-- Critical unique indices for identity lookups
CREATE UNIQUE INDEX "IX_Users_UserName" ON "$SecuritySchemaName$"."Users" ("NormalizedUserName");
CREATE UNIQUE INDEX "IX_Users_Email" ON "$SecuritySchemaName$"."Users" ("NormalizedEmail");

-- Performance indices for common authentication queries
CREATE INDEX "IX_Users_EmailConfirmed" ON "$SecuritySchemaName$"."Users" ("EmailConfirmed");
CREATE INDEX "IX_Users_LockoutEnd" ON "$SecuritySchemaName$"."Users" ("LockoutEnd");

-- Data quality constraints for Users table
ALTER TABLE "$SecuritySchemaName$"."Users" ADD CONSTRAINT "CHK_Users_NormalizedUserName_NotBlank" 
    CHECK ("NormalizedUserName" = TRIM("NormalizedUserName") AND LENGTH(TRIM("NormalizedUserName")) > 0);
ALTER TABLE "$SecuritySchemaName$"."Users" ADD CONSTRAINT "CHK_Users_NormalizedEmail_NotBlank" 
    CHECK ("NormalizedEmail" = TRIM("NormalizedEmail") AND LENGTH(TRIM("NormalizedEmail")) > 0);

/*
==============================================================================
USER CLAIMS TABLE
==============================================================================
Stores claims (permissions/attributes) associated with individual users
Enables user-specific authorization beyond role-based permissions
*/
CREATE TABLE "$SecuritySchemaName$"."UserClaims" (
    "Id"                          INTEGER                       NOT NULL GENERATED BY DEFAULT AS IDENTITY,
    "UserId"                      UUID                          NOT NULL,         -- Foreign key to Users table
    "ClaimType"                   TEXT                          NOT NULL,         -- Claim type (e.g., "department")
    "ClaimValue"                  TEXT,                                           -- Claim value (e.g., "engineering")
    CONSTRAINT "PK_UserClaims" PRIMARY KEY ("Id")
);

-- Performance indices for authorization queries
CREATE INDEX "IX_UserClaims_UserId" ON "$SecuritySchemaName$"."UserClaims" ("UserId");
CREATE INDEX "IX_UserClaims_ClaimType" ON "$SecuritySchemaName$"."UserClaims" ("ClaimType");

-- Maintain referential integrity with cascade delete
ALTER TABLE "$SecuritySchemaName$"."UserClaims" ADD CONSTRAINT "FK_UserClaims_UserId" 
    FOREIGN KEY ("UserId") REFERENCES "$SecuritySchemaName$"."Users" ("Id") 
    ON DELETE CASCADE;

-- Data quality constraints for UserClaims table
ALTER TABLE "$SecuritySchemaName$"."UserClaims" ADD CONSTRAINT "CHK_UserClaims_ClaimType_NotBlank" 
    CHECK ("ClaimType" = TRIM("ClaimType") AND LENGTH(TRIM("ClaimType")) > 0);

/*
==============================================================================
USER LOGINS TABLE
==============================================================================
Associates users with external authentication providers (Google, Microsoft, etc.)
Enables social login and external identity provider integration
*/
CREATE TABLE "$SecuritySchemaName$"."UserLogins" (
    "LoginProvider"               TEXT                          NOT NULL,         -- Provider name (e.g., "Google", "Microsoft")
    "ProviderKey"                 TEXT                          NOT NULL,         -- User's unique ID at the provider
    "ProviderDisplayName"         TEXT,                                           -- Human-readable provider name
    "UserId"                      UUID                          NOT NULL,         -- Foreign key to Users table
    CONSTRAINT "PK_UserLogins" PRIMARY KEY ("LoginProvider", "ProviderKey")       -- Composite key ensures uniqueness
);

-- Performance indices for login provider queries
CREATE INDEX "IX_UserLogins_UserId" ON "$SecuritySchemaName$"."UserLogins" ("UserId");
CREATE INDEX "IX_UserLogins_LoginProvider" ON "$SecuritySchemaName$"."UserLogins" ("LoginProvider");
CREATE INDEX "IX_UserLogins_ProviderKey" ON "$SecuritySchemaName$"."UserLogins" ("ProviderKey");

-- Maintain referential integrity with cascade delete
ALTER TABLE "$SecuritySchemaName$"."UserLogins" ADD CONSTRAINT "FK_UserLogins_UserId" 
    FOREIGN KEY ("UserId") REFERENCES "$SecuritySchemaName$"."Users" ("Id") 
    ON DELETE CASCADE;

-- Data quality constraints for UserLogins table
ALTER TABLE "$SecuritySchemaName$"."UserLogins" ADD CONSTRAINT "CHK_UserLogins_LoginProvider_NotBlank" 
    CHECK ("LoginProvider" = TRIM("LoginProvider") AND LENGTH(TRIM("LoginProvider")) > 0);
ALTER TABLE "$SecuritySchemaName$"."UserLogins" ADD CONSTRAINT "CHK_UserLogins_ProviderKey_NotBlank" 
    CHECK ("ProviderKey" = TRIM("ProviderKey") AND LENGTH(TRIM("ProviderKey")) > 0);

/*
==============================================================================
USER ROLES TABLE
==============================================================================
Many-to-many junction table linking users to roles
Enables role-based authorization and group membership management
*/
CREATE TABLE "$SecuritySchemaName$"."UserRoles" (
    "UserId"                      UUID                          NOT NULL,         -- Foreign key to Users table
    "RoleId"                      UUID                          NOT NULL,         -- Foreign key to Roles table
    CONSTRAINT "PK_UserRoles" PRIMARY KEY ("UserId", "RoleId")                    -- Composite key prevents duplicate assignments
);

-- Performance indices for role membership queries
CREATE INDEX "IX_UserRoles_UserId" ON "$SecuritySchemaName$"."UserRoles" ("UserId");
CREATE INDEX "IX_UserRoles_RoleId" ON "$SecuritySchemaName$"."UserRoles" ("RoleId");

-- Maintain referential integrity with cascade delete
ALTER TABLE "$SecuritySchemaName$"."UserRoles" ADD CONSTRAINT "FK_UserRoles_UserId" 
    FOREIGN KEY ("UserId") REFERENCES "$SecuritySchemaName$"."Users" ("Id") 
    ON DELETE CASCADE;
ALTER TABLE "$SecuritySchemaName$"."UserRoles" ADD CONSTRAINT "FK_UserRoles_RoleId" 
    FOREIGN KEY ("RoleId") REFERENCES "$SecuritySchemaName$"."Roles" ("Id") 
    ON DELETE CASCADE;

/*
==============================================================================
USER TOKENS TABLE
==============================================================================
Stores authentication tokens for users (password reset, email confirmation, etc.)
Enables secure token-based operations like account verification and recovery
*/
CREATE TABLE "$SecuritySchemaName$"."UserTokens" (
    "UserId"                      UUID                          NOT NULL,         -- Foreign key to Users table
    "LoginProvider"               TEXT                          NOT NULL,         -- Token provider (e.g., "Default", "Email")
    "Name"                        TEXT                          NOT NULL,         -- Token purpose (e.g., "ResetPassword", "ConfirmEmail")
    "Value"                       TEXT,                                           -- Encrypted/hashed token value
    CONSTRAINT "PK_UserTokens" PRIMARY KEY ("UserId", "LoginProvider", "Name")    -- Composite key ensures uniqueness per user/provider/purpose
);

-- Performance indices for token validation queries
CREATE INDEX "IX_UserTokens_UserId" ON "$SecuritySchemaName$"."UserTokens" ("UserId");
CREATE INDEX "IX_UserTokens_LoginProvider" ON "$SecuritySchemaName$"."UserTokens" ("LoginProvider");
CREATE INDEX "IX_UserTokens_Name" ON "$SecuritySchemaName$"."UserTokens" ("Name");

-- Maintain referential integrity with cascade delete
ALTER TABLE "$SecuritySchemaName$"."UserTokens" ADD CONSTRAINT "FK_UserTokens_UserId" 
    FOREIGN KEY ("UserId") REFERENCES "$SecuritySchemaName$"."Users" ("Id") 
    ON DELETE CASCADE;

-- Data quality constraints for UserTokens table
ALTER TABLE "$SecuritySchemaName$"."UserTokens" ADD CONSTRAINT "CHK_UserTokens_LoginProvider_NotBlank" 
    CHECK ("LoginProvider" = TRIM("LoginProvider") AND LENGTH(TRIM("LoginProvider")) > 0);
ALTER TABLE "$SecuritySchemaName$"."UserTokens" ADD CONSTRAINT "CHK_UserTokens_Name_NotBlank" 
    CHECK ("Name" = TRIM("Name") AND LENGTH(TRIM("Name")) > 0);

/*
==============================================================================
SCHEMA DEPLOYMENT COMPLETE
==============================================================================
The ASP.NET Core Identity schema has been successfully created with:
- 7 tables for complete Identity functionality
- Optimized indexing for query performance
- Foreign key constraints for data integrity
- PostgreSQL-specific optimizations (UUID, CITEXT)
- Comprehensive documentation for maintainability
==============================================================================
*/
